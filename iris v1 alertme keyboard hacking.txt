debuging the iris v1 keypad.

I have finished the driver and all receive functions are working.

Whats needed is to get the sending part working. from the Iris source code
it says that the keyboard needs to be told its state and it give some data 
and says you have to send on the same cluster you rec on.

"* Most messages are sent and received on the Attribute Cluster (0x00C0)"

But the code is so fragmented I cant find the format to send the data.
The java code is not clear I have yet to find the section where it actualy
sends a command and shows the order it sends it in. There are varables on top of varables.

If you understand this mess of java script and can follow this I need your help.

Unless you what to help in trying to hit on a command that works. 

I think the command are a simple 01 02 03 04 but I cant get a responce to that.
It may be more complex. When receiving the command it sends a letter A H P ascii encoded into hex.

I need to find the command to arm the keyboard and then the command to trigger the chimes its 
likely they will be send teh same way. Right now im lost.....

Links 
ZB_AlertMe_KeyPad_2_4.driver (They call it a driver but it looks nothing like a driver)
https://github.com/arcus-smart-home/arcusplatform/blob/a02ad0e9274896806b7d0108ee3644396f3780ad/platform/arcus-containers/driver-services/src/main/resources/ZB_AlertMe_KeyPad_2_4.driver

AlertmeKeyPad.java ( the first command look like what is received the other sound commands are unclear)

https://github.com/arcus-smart-home/arcusplatform/blob/a02ad0e9274896806b7d0108ee3644396f3780ad/agent/arcus-reflex-controller/src/main/java/com/iris/agent/reflex/drivers/AlertmeKeyPad.java

Directory ame = alertme
https://github.com/arcus-smart-home/arcusplatform/tree/a02ad0e9274896806b7d0108ee3644396f3780ad/common/arcus-protocol/src/main/irp

This is from the files 20,00 is the lifeline the keypad sends all the time Im thinking the 20,00 will change once its armed
likely to KEYPADSTATE shown here.

   private static final int AME_ATTR_KEYPADSTATE = 0x0020;
   private static final int AME_ATTR_PIN = 0x0021;
   private static final int AME_ATTR_ACTIONKEYPRESS = 0x0022;
   private static final int AME_ATTR_ACTIONKEYRELEASE = 0x0023;
   private static final int AME_ATTR_HUBPOLLRATE = 0x0024;
   private static final int AME_ATTR_SOUNDS_MASK = 0x0025;
   private static final int AME_ATTR_SOUNDID = 0x0026;
   private static final int AME_ATTR_UNSUCCESSFUL_STATECHANGE = 0x0028;

   private static final byte NO_REPEAT = (byte)0x00;
   private static final byte VOL_MAX = (byte)0xFF;
   private static final byte VOL_MID = (byte)0x80;
   private static final byte VOL_LOW = (byte)0x40;
   private static final byte VOL_OFF = (byte)0x00;

   private static final byte SOUNDID_CUSTOM = 0x00;
   private static final byte SOUNDID_KEYCLICK = 0x01;
   private static final byte SOUNDID_LOSTHUB = 0x02;
   private static final byte SOUNDID_ARMING = 0x03;
   private static final byte SOUNDID_ARMED = 0x04;
   private static final byte SOUNDID_HOME = 0x05;
   private static final byte SOUNDID_NIGHT = 0x06;
   private static final byte SOUNDID_ALARM = 0x07;
   private static final byte SOUNDID_PANIC = 0x08;
   private static final byte SOUNDID_BADPIN = 0x09;
   private static final byte SOUNDID_OPENDOOR = 0x0A;
   private static final byte SOUNDID_LOCKED = 0x0B;

   private static final byte KEYPADSTATE_UNKNOWN = 0;
   private static final byte KEYPADSTATE_OFF = 1;
   private static final byte KEYPADSTATE_ARMED_ON = 2;
   private static final byte KEYPADSTATE_ARMED_PARTIAL = 3;
   private static final byte KEYPADSTATE_PANIC = 4;
   private static final byte KEYPADSTATE_ARMING_ON = 5;
   private static final byte KEYPADSTATE_SOAKING_ON = 5;
   private static final byte KEYPADSTATE_ALARMING_ON = 6;
   private static final byte KEYPADSTATE_ARMING_PARTIAL = 7;
   private static final byte KEYPADSTATE_SOAKING_PARTIAL = 7;
   private static final byte KEYPADSTATE_ALARMING_PARTIAL = 8;

   private static final int SOUNDIDX_CUSTOM                     = 0x0100;
   private static final int SOUNDIDX_KEYCLICK                   = 0x0200;
   private static final int SOUNDIDX_LOSTHUB                    = 0x0400;
   private static final int SOUNDIDX_ARMING                     = 0x0800;
   private static final int SOUNDIDX_ARMED                      = 0x1000;
   private static final int SOUNDIDX_HOME                       = 0x2000;
   private static final int SOUNDIDX_NIGHT                      = 0x4000;
   private static final int SOUNDIDX_ALARM                      = 0x8000;
   private static final int SOUNDIDX_PANIC                      = 0x0001;
   private static final int SOUNDIDX_BADPIN                     = 0x0002;
   private static final int SOUNDIDX_OPENDOOR                   = 0x0004;
   private static final int SOUNDIDX_LOCKED                     = 0x0008;

Expermenting.

I added the send command under the switch on so I can send it from the driver screen with on
and then monitor what the log says. 

UPDATE the format is this 
{11 00 02 20 03}  20 is command 03 is data        {11 00 02 20 cmd} should set the pad state

If its correct that the command is 20 this is the proper position and next to it should be the state 03
sendZigbeeCommands(["he raw ${device.deviceNetworkId} 0 ${device.endpointId} 0x00C0 {11 00 02 20 03} {0xC216}"])
But the above does not work. 

I also discovered the the Care Fob uses the same Cluster 00C0 and also wants a command sent back to it to verify signal was sent
The hubitat knows this code and sends it but the internal drivers are not published. The iris source says the command is 2 for the care fob
Im still not sure that the command should even be sent on 00C0. As I get nothing but replies back no actions


So I add this 
sendZigbeeCommands(["he raw ${device.deviceNetworkId} 0 ${device.endpointId} 0x00C0 02 {11 10 00 00 01} {0xC216}"])

Sometimes the light flashes on the keyboard I think this is a error. If it takes the commnd it will reply back as

00CO 01 [xxxxxx]  The data makes no sence

So far.... Im sending whats on the left and get back whats on the right. So far nothing has happned
Do I send the 1 2  4 or do I send the words ALEART converted to hex and then reversed?
All data received from the device like the voltage and temp is reversed.


/*
Testing sending state to keypad by Pressing on on driver screen
Running from bottom up....
{11 00 00 06 00 26 } flashes
{11 00 00 06 26}         [06, 26, 00, 19, 01, 00] 19 is back with a 01
{11 00 26 00 06} ignored
{11 00 00 26 00 06}  ignored
{11 00 00 00 00 26 00 06} flashes
{11 00 00 00 26 00 06}   [00, 26, 00, 18, 00, 00, 06, 00, 18, 00]
{11 00 00 26 00 06 00}   [26, 00, 86, 06, 00, 00, 19, 01, 00]SO now I have 3 fields with a 19 and a 1
{11 00 00 26 00 00 06}   [26, 00, 86, 00, 06, 00, 18, 00] So 2 fields perhaps the command in 1 and the action in 2
{11 00 00 01 00 26 06}   [01, 00, 86, 26, 06, 86] so 86 shows up with data sent 18 with null
{11 00 00 00 00 26 06}   [00, 00, 00, 18, 00, 26, 06, 86] So now i get 18 in the first field and 86 in the second
{11 00 00 26 06 26 06}   [26, 06, 86, 26, 06, 86]
{11 00 00 26 06}    [26, 06, 86] send sound ID opendoor 26 06 
{11 00 00 02 21}    [02, 21, 86] 86 again
{11 00 00 00 02 21} flashes
{11 00 00 00 21 02} flashes
{11 00 00 21 00 02} flashes
{11 00 00 21 02}    [21, 02, 00, 42, 00]
{11 00 00 21 01}       tried to send 21 set to 1 arming  received [21, 01, 00, 42, 00] 42=B 41=A would be looking for A not B
{11 00 00 26 07}       tried to send 26 sound code 07  received [26, 07, 86]  <86= ??error??
{11 00 00 26 08 00}​   tried to send 26 = "Sound ID" and SOUNDIDX_ARMING= 0x0800 flashes
{11 00 00 25 08 00}​   tried to send 25 = "sound mask" and SOUNDIDX_ARMING= 0x0800 flashes

Any help in trying to get the keypad to arm is welcome see docs and status here

https://github.com/tmastersmart/hubitat-code
*/


  sent            received
{11 10 00 00 01} [00, 01, 00, 18, 00, 00, 01, 00, 18, 00]
{11 10 00 01 01} [01, 01, 86]
{11 10 00 01 00} [01, 00, 86]
{11 10 00 10 00} [10, 00, 86]
{11 10 00 09 00} [09, 00, 00, 19, D4, FF]
{11 10 00 00 22} [00, 22, 00, 18, 00]
{11 10 00 00 08} [00, 08, 00, 18, 0
{11 10 08 00 00} reverse i 
{11 10 00 08 00} [08, 00, 00, 23, 30, 01, 00, 00] trying to send 0x0800 arming command 23=# 30=0
{11 10 03 03 03} ignored
{11 10 00 03 03}  [03, 03, 00, 1B, 1C, 00, 00, 00]
{11 10 00 30 02}  matches format [30, 02, 86, 30, 02, 86]
{00 1 00 03 00 02} flash lights
{00 1 00 03 00}  [03, 00, 00, 1B, 1C, 00, 00, 00]
{00 0 00 03 00}  [03, 00, 00, 1B, 1C, 00, 00, 00]
{23 0 00 03 00}  [03, 00, 00, 1B, 1C, 00, 00, 00] looks to ignore first 2
{11 0 FC 03 00} i
{11 0 00 03 00}  [03, 00, 00, 1B, 1C, 00, 00, 00]
{11 0 00 00 05}  [00, 05, 00, 18, 00]
{11 0 01 00 05} ignored
{11 0 02 00 05}  flash
{11 0 05 00 05}   flash
{11 0 05 05 05}  flash
{11 0 00 05 05}     [05, 05, 00, 1A, 02, 08, 14]
{11 0 00 05 05}     [05, 05, 00, 1A, 02, 08, 14]
{11 0 00 00 05}     [00, 05, 00, 18, 00, 00, 05, 00, 18, 00]
{11 0 05 00 01}
{11 0 00 00 01}     [00, 01, 00, 18, 00]
{11 1 01 01 01}
{1 00 01 01 03}  ignored
{11 00 01 40 3}     [14, 03, 86]
{11 00 00 30 3}     [03, 03, 00, 1B, 1C, 00, 00, 00]
{11 00 02 00 3}     [20, 03, 00, 30, 00]
{11 00 00 00 3} get [00, 03, 00, 18, 00, 00, 03, 00, 18, 00] whats 18 
{11 00 02 00 0} get [20, 00, 00, 30, 00]
{11 00 02 00 02} get flash
{11 00 02 00 2} send 20 02 get back [20, 02, 00, 30, 00] is 30 a ok and 86 error?
{11 00 02 00 1} send 20 01 get back [20, 01, 00, 30, 00] the 86 changed to 30
{11 00 04 10 0} send 41 get back 41 00 86 


{11 00 00 10 0}  get 01 00 86 
[01, 00, 86, 01, 00, 86]
:[10, 00, 86] send 01 get back 10
{110009000 send 09 get 90 86
[90 00 86]
{110041000} send chr A Got no return

{11000A000}  Send A get A0
[A0 00 86] Get A0 86 
==========================================================================================

02 {01000003030000000000000000}
[03, 03, 00, 1B, 1C, 00, 00, 00]

02 {030000303000}   flashes
02 {200000050000000000000000}
01 {200000050000000000000000}

02 {230000000400000000000000  flashes
01 {230000000400000000000000} flashes
02 {200000000400000000000000}  nothing
=============================================

//"keypad:enabledSounds": ["ARMED", "ARMING", "SOAKING", "ALERTING", "DISARMED", "BUTTONS"],

This comes from the source code but I think its just local names I dont think its what we send.

I am thinking that these are the commands that need to be sent.
But they may just be internal flags.

   private static final byte KEYPADSTATE_UNKNOWN = 0;
   private static final byte KEYPADSTATE_OFF = 1;
   private static final byte KEYPADSTATE_ARMED_ON = 2;
   private static final byte KEYPADSTATE_ARMED_PARTIAL = 3;
   private static final byte KEYPADSTATE_PANIC = 4;
   private static final byte KEYPADSTATE_ARMING_ON = 5;
   private static final byte KEYPADSTATE_SOAKING_ON = 5;
   private static final byte KEYPADSTATE_ALARMING_ON = 6;
   private static final byte KEYPADSTATE_ARMING_PARTIAL = 7;
   private static final byte KEYPADSTATE_SOAKING_PARTIAL = 7;
   private static final byte KEYPADSTATE_ALARMING_PARTIAL = 8;




